/**
 * Vulnerability Scanning Module
 * Provides container image, dependency, and code vulnerability scanning
 */

import * as crypto from 'crypto';
import * as fs from 'fs';
import * as path from 'path';
import { SecurityEvent, SecuritySeverity } from './types';

export interface Vulnerability {
  id: string;
  cveId?: string;
  title: string;
  description: string;
  severity: SecuritySeverity;
  cvssScore?: number;
  cvssVector?: string;
  affectedPackage: string;
  affectedVersions: string;
  fixedVersion?: string;
  source: 'container' | 'dependency' | 'code' | 'config';
  category: VulnerabilityCategory;
  references: string[];
  publishedAt?: Date;
  detectedAt: Date;
  status: 'open' | 'fixed' | 'ignored' | 'false-positive';
  remediation?: string;
}

export type VulnerabilityCategory =
  | 'injection'
  | 'broken-auth'
  | 'sensitive-data'
  | 'xxe'
  | 'broken-access'
  | 'security-misconfig'
  | 'xss'
  | 'insecure-deserialization'
  | 'vulnerable-components'
  | 'insufficient-logging'
  | 'ssrf'
  | 'other';

export interface ScanResult {
  id: string;
  scanType: 'container' | 'dependency' | 'code' | 'config' | 'full';
  target: string;
  startedAt: Date;
  completedAt: Date;
  status: 'success' | 'failed' | 'partial';
  vulnerabilities: Vulnerability[];
  summary: {
    total: number;
    critical: number;
    high: number;
    medium: number;
    low: number;
  };
  metadata?: Record<string, unknown>;
}

export interface ContainerImageInfo {
  name: string;
  tag: string;
  digest?: string;
  registry?: string;
  layers?: string[];
  createdAt?: Date;
  size?: number;
}

export interface DependencyInfo {
  name: string;
  version: string;
  type: 'npm' | 'pip' | 'go' | 'maven' | 'cargo' | 'gem' | 'nuget';
  direct: boolean;
  dependencies?: DependencyInfo[];
}

interface VulnerabilityDatabase {
  lastUpdated: Date;
  vulnerabilities: Map<string, Vulnerability[]>;
}

type ScanCallback = (result: ScanResult) => void | Promise<void>;

export class VulnerabilityScannerService {
  private vulnerabilityDb: VulnerabilityDatabase;
  private scanHistory: ScanResult[];
  private ignoredVulnerabilities: Set<string>;
  private scanCallbacks: ScanCallback[];
  private eventCallback?: (event: SecurityEvent) => void;

  constructor() {
    this.vulnerabilityDb = {
      lastUpdated: new Date(),
      vulnerabilities: new Map(),
    };
    this.scanHistory = [];
    this.ignoredVulnerabilities = new Set();
    this.scanCallbacks = [];

    this.loadKnownVulnerabilities();
  }

  /**
   * Set callback for security events
   */
  onSecurityEvent(callback: (event: SecurityEvent) => void): void {
    this.eventCallback = callback;
  }

  /**
   * Register scan callback
   */
  onScanComplete(callback: ScanCallback): void {
    this.scanCallbacks.push(callback);
  }

  /**
   * Scan container image for vulnerabilities
   */
  async scanContainerImage(image: ContainerImageInfo): Promise<ScanResult> {
    const startedAt = new Date();
    const vulnerabilities: Vulnerability[] = [];

    try {
      // In production, this would use tools like Trivy, Clair, or Anchore
      // For now, simulate scanning with known vulnerability patterns

      // Check for common vulnerable base images
      vulnerabilities.push(...this.checkBaseImageVulnerabilities(image));

      // Check for exposed secrets in layers
      vulnerabilities.push(...this.checkContainerSecrets(image));

      // Check for outdated packages
      vulnerabilities.push(...this.checkOutdatedPackages(image));

      const result = this.createScanResult(
        'container',
        `${image.name}:${image.tag}`,
        startedAt,
        vulnerabilities,
        { imageDigest: image.digest, registry: image.registry }
      );

      await this.notifyScanComplete(result);
      return result;
    } catch (error) {
      return this.createScanResult(
        'container',
        `${image.name}:${image.tag}`,
        startedAt,
        vulnerabilities,
        { error: (error as Error).message },
        'failed'
      );
    }
  }

  /**
   * Scan dependencies for vulnerabilities
   */
  async scanDependencies(
    dependencies: DependencyInfo[],
    projectPath?: string
  ): Promise<ScanResult> {
    const startedAt = new Date();
    const vulnerabilities: Vulnerability[] = [];

    try {
      for (const dep of dependencies) {
        const depVulns = this.checkDependencyVulnerabilities(dep);
        vulnerabilities.push(...depVulns);

        // Recursively check transitive dependencies
        if (dep.dependencies) {
          for (const transitive of dep.dependencies) {
            vulnerabilities.push(...this.checkDependencyVulnerabilities(transitive));
          }
        }
      }

      const result = this.createScanResult(
        'dependency',
        projectPath || 'dependencies',
        startedAt,
        vulnerabilities,
        { dependencyCount: dependencies.length }
      );

      await this.notifyScanComplete(result);
      return result;
    } catch (error) {
      return this.createScanResult(
        'dependency',
        projectPath || 'dependencies',
        startedAt,
        vulnerabilities,
        { error: (error as Error).message },
        'failed'
      );
    }
  }

  /**
   * Scan package.json for npm vulnerabilities
   */
  async scanNpmProject(packageJsonPath: string): Promise<ScanResult> {
    const startedAt = new Date();
    const vulnerabilities: Vulnerability[] = [];

    try {
      const content = fs.readFileSync(packageJsonPath, 'utf-8');
      const packageJson = JSON.parse(content);

      const dependencies: DependencyInfo[] = [];

      // Add direct dependencies
      if (packageJson.dependencies) {
        for (const [name, version] of Object.entries(packageJson.dependencies)) {
          dependencies.push({
            name,
            version: String(version).replace(/^[\^~]/, ''),
            type: 'npm',
            direct: true,
          });
        }
      }

      // Add dev dependencies
      if (packageJson.devDependencies) {
        for (const [name, version] of Object.entries(packageJson.devDependencies)) {
          dependencies.push({
            name,
            version: String(version).replace(/^[\^~]/, ''),
            type: 'npm',
            direct: true,
          });
        }
      }

      return this.scanDependencies(dependencies, packageJsonPath);
    } catch (error) {
      return this.createScanResult(
        'dependency',
        packageJsonPath,
        startedAt,
        vulnerabilities,
        { error: (error as Error).message },
        'failed'
      );
    }
  }

  /**
   * Scan requirements.txt for Python vulnerabilities
   */
  async scanPythonProject(requirementsPath: string): Promise<ScanResult> {
    const startedAt = new Date();
    const vulnerabilities: Vulnerability[] = [];

    try {
      const content = fs.readFileSync(requirementsPath, 'utf-8');
      const lines = content.split('\n').filter(l => l.trim() && !l.startsWith('#'));

      const dependencies: DependencyInfo[] = lines.map(line => {
        const match = line.match(/^([a-zA-Z0-9_-]+)([=<>!~]+)?(.+)?$/);
        if (match) {
          return {
            name: match[1],
            version: match[3] || 'latest',
            type: 'pip' as const,
            direct: true,
          };
        }
        return {
          name: line.trim(),
          version: 'unknown',
          type: 'pip' as const,
          direct: true,
        };
      });

      return this.scanDependencies(dependencies, requirementsPath);
    } catch (error) {
      return this.createScanResult(
        'dependency',
        requirementsPath,
        startedAt,
        vulnerabilities,
        { error: (error as Error).message },
        'failed'
      );
    }
  }

  /**
   * Scan go.mod for Go vulnerabilities
   */
  async scanGoProject(goModPath: string): Promise<ScanResult> {
    const startedAt = new Date();
    const vulnerabilities: Vulnerability[] = [];

    try {
      const content = fs.readFileSync(goModPath, 'utf-8');
      const requireMatches = content.matchAll(/require\s+([^\s]+)\s+v?([^\s\n]+)/g);

      const dependencies: DependencyInfo[] = [];
      for (const match of requireMatches) {
        dependencies.push({
          name: match[1],
          version: match[2],
          type: 'go',
          direct: true,
        });
      }

      return this.scanDependencies(dependencies, goModPath);
    } catch (error) {
      return this.createScanResult(
        'dependency',
        goModPath,
        startedAt,
        vulnerabilities,
        { error: (error as Error).message },
        'failed'
      );
    }
  }

  /**
   * Scan code for security issues
   */
  async scanCode(codePath: string, language?: string): Promise<ScanResult> {
    const startedAt = new Date();
    const vulnerabilities: Vulnerability[] = [];

    try {
      // In production, would use tools like Semgrep, CodeQL, or SonarQube
      // For now, perform basic pattern matching

      const files = this.getSourceFiles(codePath, language);

      for (const file of files) {
        const content = fs.readFileSync(file, 'utf-8');
        vulnerabilities.push(...this.scanFileForSecurityIssues(file, content));
      }

      const result = this.createScanResult(
        'code',
        codePath,
        startedAt,
        vulnerabilities,
        { filesScanned: files.length }
      );

      await this.notifyScanComplete(result);
      return result;
    } catch (error) {
      return this.createScanResult(
        'code',
        codePath,
        startedAt,
        vulnerabilities,
        { error: (error as Error).message },
        'failed'
      );
    }
  }

  /**
   * Scan configuration files
   */
  async scanConfig(configPath: string): Promise<ScanResult> {
    const startedAt = new Date();
    const vulnerabilities: Vulnerability[] = [];

    try {
      const content = fs.readFileSync(configPath, 'utf-8');

      // Check for hardcoded secrets
      vulnerabilities.push(...this.checkHardcodedSecrets(configPath, content));

      // Check for insecure configurations
      vulnerabilities.push(...this.checkInsecureConfig(configPath, content));

      const result = this.createScanResult(
        'config',
        configPath,
        startedAt,
        vulnerabilities
      );

      await this.notifyScanComplete(result);
      return result;
    } catch (error) {
      return this.createScanResult(
        'config',
        configPath,
        startedAt,
        vulnerabilities,
        { error: (error as Error).message },
        'failed'
      );
    }
  }

  /**
   * Full security scan
   */
  async fullScan(projectPath: string): Promise<ScanResult[]> {
    const results: ScanResult[] = [];

    // Scan dependencies based on project type
    const packageJsonPath = path.join(projectPath, 'package.json');
    if (fs.existsSync(packageJsonPath)) {
      results.push(await this.scanNpmProject(packageJsonPath));
    }

    const requirementsPath = path.join(projectPath, 'requirements.txt');
    if (fs.existsSync(requirementsPath)) {
      results.push(await this.scanPythonProject(requirementsPath));
    }

    const goModPath = path.join(projectPath, 'go.mod');
    if (fs.existsSync(goModPath)) {
      results.push(await this.scanGoProject(goModPath));
    }

    // Scan code
    results.push(await this.scanCode(projectPath));

    // Scan common config files
    const configFiles = [
      '.env',
      '.env.example',
      'config.json',
      'docker-compose.yml',
      'Dockerfile',
    ];

    for (const configFile of configFiles) {
      const configPath = path.join(projectPath, configFile);
      if (fs.existsSync(configPath)) {
        results.push(await this.scanConfig(configPath));
      }
    }

    return results;
  }

  /**
   * Check base image vulnerabilities
   */
  private checkBaseImageVulnerabilities(image: ContainerImageInfo): Vulnerability[] {
    const vulnerabilities: Vulnerability[] = [];

    // Known vulnerable base images
    const vulnerableImages: Record<string, { version: string; cve: string; severity: SecuritySeverity }[]> = {
      'node': [
        { version: '14', cve: 'CVE-2023-XXXX', severity: 'high' },
        { version: '16', cve: 'CVE-2023-YYYY', severity: 'medium' },
      ],
      'python': [
        { version: '3.7', cve: 'CVE-2022-XXXX', severity: 'critical' },
      ],
      'alpine': [
        { version: '3.12', cve: 'CVE-2021-XXXX', severity: 'high' },
      ],
    };

    const imageBase = image.name.split('/').pop()?.split(':')[0] || '';

    if (vulnerableImages[imageBase]) {
      for (const vuln of vulnerableImages[imageBase]) {
        if (image.tag.startsWith(vuln.version)) {
          vulnerabilities.push({
            id: crypto.randomUUID(),
            cveId: vuln.cve,
            title: `Vulnerable base image: ${imageBase}:${vuln.version}`,
            description: `The base image ${imageBase}:${image.tag} contains known vulnerabilities`,
            severity: vuln.severity,
            affectedPackage: image.name,
            affectedVersions: image.tag,
            source: 'container',
            category: 'vulnerable-components',
            references: [`https://nvd.nist.gov/vuln/detail/${vuln.cve}`],
            detectedAt: new Date(),
            status: 'open',
            remediation: `Update to a patched version of ${imageBase}`,
          });
        }
      }
    }

    return vulnerabilities;
  }

  /**
   * Check for secrets in container
   */
  private checkContainerSecrets(image: ContainerImageInfo): Vulnerability[] {
    // In production, would analyze container layers
    return [];
  }

  /**
   * Check for outdated packages
   */
  private checkOutdatedPackages(image: ContainerImageInfo): Vulnerability[] {
    // In production, would analyze installed packages
    return [];
  }

  /**
   * Check dependency vulnerabilities
   */
  private checkDependencyVulnerabilities(dep: DependencyInfo): Vulnerability[] {
    const vulnerabilities: Vulnerability[] = [];
    const depKey = `${dep.type}:${dep.name}`;
    const knownVulns = this.vulnerabilityDb.vulnerabilities.get(depKey) || [];

    for (const vuln of knownVulns) {
      if (this.isVersionAffected(dep.version, vuln.affectedVersions)) {
        if (!this.ignoredVulnerabilities.has(vuln.id)) {
          vulnerabilities.push({
            ...vuln,
            detectedAt: new Date(),
          });
        }
      }
    }

    return vulnerabilities;
  }

  /**
   * Check if version is affected
   */
  private isVersionAffected(version: string, affectedRange: string): boolean {
    // Simplified version checking
    // In production, would use semver library
    if (affectedRange.includes('<')) {
      const maxVersion = affectedRange.replace('<', '').trim();
      return version < maxVersion;
    }
    if (affectedRange.includes('=')) {
      return affectedRange.includes(version);
    }
    return false;
  }

  /**
   * Get source files for scanning
   */
  private getSourceFiles(dirPath: string, language?: string): string[] {
    const files: string[] = [];
    const extensions = language
      ? this.getExtensionsForLanguage(language)
      : ['.ts', '.js', '.py', '.go', '.java', '.rb', '.php'];

    try {
      const entries = fs.readdirSync(dirPath, { withFileTypes: true });

      for (const entry of entries) {
        const fullPath = path.join(dirPath, entry.name);

        // Skip node_modules and similar
        if (entry.name === 'node_modules' || entry.name === '.git' ||
            entry.name === 'vendor' || entry.name === '__pycache__') {
          continue;
        }

        if (entry.isDirectory()) {
          files.push(...this.getSourceFiles(fullPath, language));
        } else if (extensions.some(ext => entry.name.endsWith(ext))) {
          files.push(fullPath);
        }
      }
    } catch {
      // Directory not readable
    }

    return files;
  }

  /**
   * Get file extensions for language
   */
  private getExtensionsForLanguage(language: string): string[] {
    const langExtensions: Record<string, string[]> = {
      javascript: ['.js', '.jsx', '.mjs'],
      typescript: ['.ts', '.tsx'],
      python: ['.py'],
      go: ['.go'],
      java: ['.java'],
      ruby: ['.rb'],
      php: ['.php'],
    };
    return langExtensions[language.toLowerCase()] || [];
  }

  /**
   * Scan file for security issues
   */
  private scanFileForSecurityIssues(filePath: string, content: string): Vulnerability[] {
    const vulnerabilities: Vulnerability[] = [];

    // SQL Injection patterns
    const sqlPatterns = [
      /execute\s*\(\s*["'`].*\+/gi,
      /query\s*\(\s*["'`].*\+/gi,
      /\$\{.*\}.*SELECT|INSERT|UPDATE|DELETE/gi,
    ];

    for (const pattern of sqlPatterns) {
      if (pattern.test(content)) {
        vulnerabilities.push({
          id: crypto.randomUUID(),
          title: 'Potential SQL Injection',
          description: `Potential SQL injection vulnerability detected in ${filePath}`,
          severity: 'high',
          affectedPackage: filePath,
          affectedVersions: 'current',
          source: 'code',
          category: 'injection',
          references: ['https://owasp.org/www-community/attacks/SQL_Injection'],
          detectedAt: new Date(),
          status: 'open',
          remediation: 'Use parameterized queries or prepared statements',
        });
        break;
      }
    }

    // XSS patterns
    const xssPatterns = [
      /innerHTML\s*=\s*[^"'`]*\+/gi,
      /document\.write\s*\(/gi,
      /\.html\s*\([^)]*\+/gi,
    ];

    for (const pattern of xssPatterns) {
      if (pattern.test(content)) {
        vulnerabilities.push({
          id: crypto.randomUUID(),
          title: 'Potential Cross-Site Scripting (XSS)',
          description: `Potential XSS vulnerability detected in ${filePath}`,
          severity: 'high',
          affectedPackage: filePath,
          affectedVersions: 'current',
          source: 'code',
          category: 'xss',
          references: ['https://owasp.org/www-community/attacks/xss/'],
          detectedAt: new Date(),
          status: 'open',
          remediation: 'Sanitize user input and use safe DOM manipulation methods',
        });
        break;
      }
    }

    // Command injection patterns
    const cmdPatterns = [
      /exec\s*\(\s*["'`].*\+/gi,
      /spawn\s*\(\s*["'`].*\+/gi,
      /os\.system\s*\(/gi,
      /subprocess\.\w+\s*\([^)]*shell\s*=\s*True/gi,
    ];

    for (const pattern of cmdPatterns) {
      if (pattern.test(content)) {
        vulnerabilities.push({
          id: crypto.randomUUID(),
          title: 'Potential Command Injection',
          description: `Potential command injection vulnerability detected in ${filePath}`,
          severity: 'critical',
          affectedPackage: filePath,
          affectedVersions: 'current',
          source: 'code',
          category: 'injection',
          references: ['https://owasp.org/www-community/attacks/Command_Injection'],
          detectedAt: new Date(),
          status: 'open',
          remediation: 'Avoid using shell execution with user input',
        });
        break;
      }
    }

    // Hardcoded credentials patterns
    vulnerabilities.push(...this.checkHardcodedSecrets(filePath, content));

    return vulnerabilities;
  }

  /**
   * Check for hardcoded secrets
   */
  private checkHardcodedSecrets(filePath: string, content: string): Vulnerability[] {
    const vulnerabilities: Vulnerability[] = [];

    const secretPatterns = [
      { pattern: /password\s*[=:]\s*["'][^"']+["']/gi, type: 'password' },
      { pattern: /api[_-]?key\s*[=:]\s*["'][^"']+["']/gi, type: 'API key' },
      { pattern: /secret\s*[=:]\s*["'][^"']+["']/gi, type: 'secret' },
      { pattern: /token\s*[=:]\s*["'][a-zA-Z0-9_-]{20,}["']/gi, type: 'token' },
      { pattern: /-----BEGIN (?:RSA |EC |DSA )?PRIVATE KEY-----/gi, type: 'private key' },
      { pattern: /aws[_-]?access[_-]?key[_-]?id\s*[=:]\s*["'][A-Z0-9]{20}["']/gi, type: 'AWS key' },
    ];

    for (const { pattern, type } of secretPatterns) {
      if (pattern.test(content)) {
        vulnerabilities.push({
          id: crypto.randomUUID(),
          title: `Hardcoded ${type} detected`,
          description: `A hardcoded ${type} was found in ${filePath}`,
          severity: 'high',
          affectedPackage: filePath,
          affectedVersions: 'current',
          source: 'code',
          category: 'sensitive-data',
          references: ['https://owasp.org/www-community/vulnerabilities/Hardcoded_Password'],
          detectedAt: new Date(),
          status: 'open',
          remediation: `Move ${type} to environment variables or secure vault`,
        });
      }
    }

    return vulnerabilities;
  }

  /**
   * Check for insecure configuration
   */
  private checkInsecureConfig(filePath: string, content: string): Vulnerability[] {
    const vulnerabilities: Vulnerability[] = [];

    // Check for insecure settings
    const insecurePatterns = [
      { pattern: /debug\s*[=:]\s*(true|1|yes|on)/gi, issue: 'Debug mode enabled' },
      { pattern: /ssl[_-]?verify\s*[=:]\s*(false|0|no|off)/gi, issue: 'SSL verification disabled' },
      { pattern: /insecure\s*[=:]\s*(true|1|yes|on)/gi, issue: 'Insecure mode enabled' },
      { pattern: /tls\s*[=:]\s*(false|0|no|off)/gi, issue: 'TLS disabled' },
    ];

    for (const { pattern, issue } of insecurePatterns) {
      if (pattern.test(content)) {
        vulnerabilities.push({
          id: crypto.randomUUID(),
          title: issue,
          description: `Insecure configuration detected in ${filePath}: ${issue}`,
          severity: 'medium',
          affectedPackage: filePath,
          affectedVersions: 'current',
          source: 'config',
          category: 'security-misconfig',
          references: [],
          detectedAt: new Date(),
          status: 'open',
          remediation: 'Review and update configuration for production use',
        });
      }
    }

    return vulnerabilities;
  }

  /**
   * Create scan result
   */
  private createScanResult(
    scanType: ScanResult['scanType'],
    target: string,
    startedAt: Date,
    vulnerabilities: Vulnerability[],
    metadata?: Record<string, unknown>,
    status: ScanResult['status'] = 'success'
  ): ScanResult {
    const result: ScanResult = {
      id: crypto.randomUUID(),
      scanType,
      target,
      startedAt,
      completedAt: new Date(),
      status,
      vulnerabilities,
      summary: {
        total: vulnerabilities.length,
        critical: vulnerabilities.filter(v => v.severity === 'critical').length,
        high: vulnerabilities.filter(v => v.severity === 'high').length,
        medium: vulnerabilities.filter(v => v.severity === 'medium').length,
        low: vulnerabilities.filter(v => v.severity === 'low').length,
      },
      metadata,
    };

    this.scanHistory.push(result);

    // Emit security events for critical/high vulnerabilities
    for (const vuln of vulnerabilities) {
      if (vuln.severity === 'critical' || vuln.severity === 'high') {
        this.emitSecurityEvent({
          id: crypto.randomUUID(),
          type: 'vulnerability-detected',
          severity: vuln.severity,
          timestamp: new Date(),
          source: 'vulnerability-scanner',
          outcome: 'failure',
          details: {
            vulnerabilityId: vuln.id,
            cveId: vuln.cveId,
            title: vuln.title,
            affectedPackage: vuln.affectedPackage,
            category: vuln.category,
          },
        });
      }
    }

    return result;
  }

  /**
   * Notify scan callbacks
   */
  private async notifyScanComplete(result: ScanResult): Promise<void> {
    for (const callback of this.scanCallbacks) {
      try {
        await callback(result);
      } catch (error) {
        console.error('Scan callback error:', error);
      }
    }
  }

  /**
   * Emit security event
   */
  private emitSecurityEvent(event: SecurityEvent): void {
    if (this.eventCallback) {
      this.eventCallback(event);
    }
  }

  /**
   * Ignore vulnerability
   */
  ignoreVulnerability(vulnerabilityId: string): void {
    this.ignoredVulnerabilities.add(vulnerabilityId);
  }

  /**
   * Unignore vulnerability
   */
  unignoreVulnerability(vulnerabilityId: string): void {
    this.ignoredVulnerabilities.delete(vulnerabilityId);
  }

  /**
   * Get scan history
   */
  getScanHistory(limit: number = 100): ScanResult[] {
    return this.scanHistory.slice(-limit);
  }

  /**
   * Get open vulnerabilities
   */
  getOpenVulnerabilities(): Vulnerability[] {
    const allVulns: Vulnerability[] = [];
    for (const result of this.scanHistory) {
      for (const vuln of result.vulnerabilities) {
        if (vuln.status === 'open' && !this.ignoredVulnerabilities.has(vuln.id)) {
          allVulns.push(vuln);
        }
      }
    }
    return allVulns;
  }

  /**
   * Update vulnerability status
   */
  updateVulnerabilityStatus(
    vulnerabilityId: string,
    status: Vulnerability['status']
  ): boolean {
    for (const result of this.scanHistory) {
      for (const vuln of result.vulnerabilities) {
        if (vuln.id === vulnerabilityId) {
          vuln.status = status;
          return true;
        }
      }
    }
    return false;
  }

  /**
   * Load known vulnerabilities database
   */
  private loadKnownVulnerabilities(): void {
    // In production, would load from NVD, OSV, or commercial database
    // For now, add some example vulnerabilities

    this.vulnerabilityDb.vulnerabilities.set('npm:lodash', [
      {
        id: 'GHSA-x5rq-j2xg-h7qm',
        cveId: 'CVE-2021-23337',
        title: 'Command Injection in lodash',
        description: 'Lodash versions prior to 4.17.21 are vulnerable to Command Injection',
        severity: 'high',
        cvssScore: 7.2,
        affectedPackage: 'lodash',
        affectedVersions: '<4.17.21',
        fixedVersion: '4.17.21',
        source: 'dependency',
        category: 'injection',
        references: ['https://nvd.nist.gov/vuln/detail/CVE-2021-23337'],
        detectedAt: new Date(),
        status: 'open',
        remediation: 'Upgrade lodash to version 4.17.21 or later',
      },
    ]);

    this.vulnerabilityDb.vulnerabilities.set('npm:axios', [
      {
        id: 'GHSA-42xw-2xvc-qx8m',
        cveId: 'CVE-2021-3749',
        title: 'Server-Side Request Forgery in axios',
        description: 'axios versions < 0.21.2 are vulnerable to SSRF',
        severity: 'medium',
        cvssScore: 5.4,
        affectedPackage: 'axios',
        affectedVersions: '<0.21.2',
        fixedVersion: '0.21.2',
        source: 'dependency',
        category: 'ssrf',
        references: ['https://nvd.nist.gov/vuln/detail/CVE-2021-3749'],
        detectedAt: new Date(),
        status: 'open',
        remediation: 'Upgrade axios to version 0.21.2 or later',
      },
    ]);

    this.vulnerabilityDb.lastUpdated = new Date();
  }

  /**
   * Get vulnerability statistics
   */
  getStatistics(): {
    totalScans: number;
    totalVulnerabilities: number;
    bySeverity: Record<string, number>;
    byCategory: Record<string, number>;
    bySource: Record<string, number>;
  } {
    const stats = {
      totalScans: this.scanHistory.length,
      totalVulnerabilities: 0,
      bySeverity: {} as Record<string, number>,
      byCategory: {} as Record<string, number>,
      bySource: {} as Record<string, number>,
    };

    for (const result of this.scanHistory) {
      for (const vuln of result.vulnerabilities) {
        stats.totalVulnerabilities++;
        stats.bySeverity[vuln.severity] = (stats.bySeverity[vuln.severity] || 0) + 1;
        stats.byCategory[vuln.category] = (stats.byCategory[vuln.category] || 0) + 1;
        stats.bySource[vuln.source] = (stats.bySource[vuln.source] || 0) + 1;
      }
    }

    return stats;
  }
}

// Factory function
export function createVulnerabilityScannerService(): VulnerabilityScannerService {
  return new VulnerabilityScannerService();
}

export default VulnerabilityScannerService;
